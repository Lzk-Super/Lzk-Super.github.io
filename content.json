[{"title":"拆箱和装箱","slug":"拆箱和装箱","date":"2019-08-21T05:40:02.000Z","updated":"2019-08-21T06:00:10.905Z","comments":true,"path":"2019/08/21/拆箱和装箱/","link":"","permalink":"http://yoursite.com/2019/08/21/拆箱和装箱/","excerpt":"","text":"一.什么是装箱？什么是拆箱？在前面的文章中提到，Java为每种基本数据类型都提供了对应的包装器类型，至于为什么会为每种基本数据类型提供包装器类型在此不进行阐述，有兴趣的朋友可以查阅相关资料。在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行： Integer i = new Integer(10);而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了： Integer i = 10; 这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。 那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型： Integer i = 10; //装箱 int n = i; //拆箱简单一点说，装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。 二.装箱和拆箱是如何实现的 上一小节了解装箱的基本概念之后，这一小节来了解一下装箱和拆箱是如何实现的。我们就以Interger类为例，下面看一段代码： public class Main { public static void main(String[] args) { Integer i = 10; int n = i; } } 反编译class文件之后得到如下内容： 从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。 其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。 因此可以用一句话总结装箱和拆箱的实现过程： 装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。 三.面试中相关的问题 虽然大多数人对装箱和拆箱的概念都清楚，但是在面试和笔试中遇到了与装箱和拆箱的问题却不一定会答得上来。下面列举一些常见的与装箱/拆箱有关的面试题。 1.下面这段代码的输出结果是什么？ public class Main { public static void main(String[] args) { Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); } }也许有些朋友会说都会输出false，或者也有朋友会说都会输出true。但是事实上输出结果是： true false为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现： public static Integer valueOf(int i) { if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + 128]; else return new Integer(i); } 而其中IntegerCache类的实现为： private static class IntegerCache { static final int high; static final Integer cache[]; static { final int low = -128; // high value may be configured by property int h = 127; if (integerCacheHighPropValue != null) { // Use Long.decode here to avoid invoking methods that // require Integer&apos;s autoboxing cache to be initialized int i = Long.decode(integerCacheHighPropValue).intValue(); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - -low); } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); } private IntegerCache() {} }从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。 上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。 2.下面这段代码的输出结果是什么？ public class Main { public static void main(String[] args) { Double i1 = 100.0; Double i2 = 100.0; Double i3 = 200.0; Double i4 = 200.0; System.out.println(i1==i2); System.out.println(i3==i4); } }也许有的朋友会认为跟上面一道题目的输出结果相同，但是事实上却不是。实际输出结果为： false false至于具体为什么，读者可以去查看Double类的valueOf的实现。 在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。 注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。 Double、Float的valueOf方法的实现是类似的。 3.下面这段代码输出结果是什么： public class Main { public static void main(String[] args) { Boolean i1 = false; Boolean i2 = false; Boolean i3 = true; Boolean i4 = true; System.out.println(i1==i2); System.out.println(i3==i4); } }输出结果是： true true至于为什么是这个结果，同样地，看了Boolean类的源码也会一目了然。下面是Boolean的valueOf方法的具体实现： public static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE); }而其中的 TRUE 和FALSE又是什么呢？在Boolean中定义了2个静态成员属性： public static final Boolean TRUE = new Boolean(true); /** * The &lt;code&gt;Boolean&lt;/code&gt; object corresponding to the primitive * value &lt;code&gt;false&lt;/code&gt;. */ public static final Boolean FALSE = new Boolean(false);至此，大家应该明白了为何上面输出的结果都是true了。 4.谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。 当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别： 1）第一种方式不会触发自动装箱的过程；而第二种方式会触发； 2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。 5.下面程序的输出结果是什么？ public class Main { public static void main(String[] args) { Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; Long h = 2L; System.out.println(c==d); System.out.println(e==f); System.out.println(c==(a+b)); System.out.println(c.equals(a+b)); System.out.println(g==(a+b)); System.out.println(g.equals(a+b)); System.out.println(g.equals(a+h)); } } 先别看输出结果，读者自己想一下这段代码的输出结果是什么。这里面需要注意的是：当 “==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。明白了这2点之后，上面的输出结果便一目了然： true false true true true false true第一个和第二个输出结果没有什么疑问。第三句由于 a+b包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。","categories":[],"tags":[]},{"title":"Java的跨平台原理","slug":"Java的跨平台原理","date":"2019-08-21T05:13:33.000Z","updated":"2019-08-21T05:20:48.521Z","comments":true,"path":"2019/08/21/Java的跨平台原理/","link":"","permalink":"http://yoursite.com/2019/08/21/Java的跨平台原理/","excerpt":"","text":"1、是么是平台 Java是可以跨平台的编程语言，那我们首先得知道什么是平台，我们把CPU处理器与操作系统的整体叫平台。 CPU大家都知道，如果计算机是人,那CPU就是人的大脑，它既负责思维运算，又负责身体各部件的命令控制。CPU的种类很多，除去我们熟知的Intel与AMD外，还有比如上面说到的SUN的Sparc,比如IBM的PowerPC等等，这些各个公司生产的CPU使用或相同或不同的指令集。指令集就是cpu中用来计算和控制计算机系统的一套指令的集合。指令集又分为精简指令集（RISC）与复杂指令集(CISC)，每种cpu都有其特定的指令集。开发程序，首先要知道该程序在什么CPU上运行,也就是要知道CPU所使用的指令集。 下面说操作系统，操作系统是充当用户和计算机之间交互的界面软件，不同的操作系统支持不同的CPU，严格意义上说是不同的操作系统支持不同CPU的指令集。例如 windows和liunx都支持Intel和AMD的复杂指令集，但并不支持PowerPC所使用的精简指令集，而早期的MAC电脑使用的是PowerPC处理器，所以也就无法在MAC下直接安装windows,直到05年MAC改用了Intel的CPU,才使在MAC下安装windows成为可能。但问题来了，原来的MAC 操作系统也只支持PowerPC,在Intel上也不能安装，怎么办？所以苹果公司也得重写自己的MAC操作系统以支持这种变化。最后总结下，我们要知道，不同的操作系统支持不同的CPU指令集，现在的windows,liunx,mac,solaris都支持Intel与AMD的CPU指令集。 有了上面的铺垫，旺旺老师就要告诉大家，如果您要开发程序，首先应该确定：1，CPU类型，也就是指令集类型；2，操作系统；我们把这种软硬件的结合叫平台。也可以说“平台= CPU+OS”。又因为现在主流的操作系统都支持主流的CPU，所以有时也把操作系统称为平台。 知道什么是平台，我们看Java跨平台原理。 2、Java跨平台原理 首先看一张与C语言有关的图： 如果您有过C的开发经历，这张图看起来将非常轻松。我们知道，只要是用标准C开发的程序，使用不同的编译器编译后的可执行文件是可以在对应平台运行的，比如windows可以使用VC编译，那编译后的exe文件就可以在windows下运行；liunx下可以使用GCC编译，生成的可执行文件就可以在Liunx上运行。到这里请大家思考一个问题：“VC编译的exe能在Liunx上运行吗？” 答案肯定是否定的。使用特定编译器编译的程序只能在对应的平台运行，这里也可以说编译器是与平台相关的，编译后的文件也是与平台相关的。我们说的语言跨平台是编译后的文件跨平台，而不是源程序跨平台，如果是源程序，任何一门语言都是跨平台的语言了。这个如果您不明白，看下面一个案例： 比 如火星真的有外星人（并且毋庸置疑，火星是韩国人的，火星文也一定是韩国人发明的），就像我们观察蚂蚁一样，火星人默默的观察着我们，有一天，当人类做的 什么事情让火星人实在是看不下去了（比如旺旺老师的书出版了你不买，哈哈，呕吐中，没关系，吐啊吐啊就吐习惯了），所以决定来地球教育我们，但有一个问 题，火星人只会说火星文，地球人理解不了，怎么办啊？找翻译呗（也许非主流可以帮忙，玩笑）！由中文翻译把火星文翻译为中文，英文翻译把火星文翻译为英文 等等等等，但这样问题来了，中文翻译翻译的东西只有中国人能听懂，美国人法国人根本不明白，英文翻译翻译的文章中国人也不明白，也就是语言不能跨平台。 那上例中，火星文就是C语言，各个国家是平台，中文翻译英文翻译就是对应平台的编译器，编译后的文章就是可执行文件。虽然源文章火星文是与平台无关的，但翻译器是与特定国家相关的，翻译后的文章也是与特定国家相关的。 接下来思考另一个问题“怎么让火星文跨平台呢？” 火 星人想到了地球上有世界语，于是首先把自己的文章翻译为世界语；世界语各国人当然看不懂，没关系，火星人又给每个国家配备了一个世界语到本地语的翻译，这 样火星文只要翻译一次（翻译为世界语），就可以到各个国家运行了。还要记住，这个过程火星人要提供两个组件，第一是火星文到世界语的翻译，第二是世界语到 对应本地语言的翻译。如下图： 有了上面案例的积累，我们也知道了语言跨平台原理：“不能编译成机器语言，因为那样就与平台相关了，编译为中间语言，再由解释器二次编译，解释执行。”如下是Java跨平台原理表示图： 上图中的.java就是源程序，类似于c语言的.c,生成的中间码是.class,这个既是我们上文中说的中间语，各个平台解释器就是各种国家翻译。 接下来我们再比较下两种方式的差异：第一，C语言是编译执行的，编译器与平台相关，编译生成的可执行文件与平台相关；第二，Java是解释执行的，编译为中间码的编译器与平台无关，编译生成的中间码也与平台无关（一次编译，到处运行），中间码再由解释器解释执行，解释器是与平台相关的，也就是不同的平台需要不同的解释器. 这里再说下语言根据执行方式的不同分类：第一是编译执行，如上文中说到的C，它把源程序由特定平台的编译器一次性编译为平台相关的机器码,它的优点是执行速度快，缺点是无法跨平台；第二是解释执行，如HTML,JavaScript，它使用特定的解释器，把代码一行行解释为机器码，类似于同声翻译，它的优点是可以跨平台，缺点是执行速度慢，暴露源程序；第三种是从Java开始引入的“中间码+虚拟机”的方式，它既整合了编译语言与解释语言的优点，同时如虚拟机又可以解决如垃圾回收，安全性检查等这些传统语言头疼的问题，所以其后微软的.NET平台也使用的这种方式。","categories":[],"tags":[]},{"title":"面向对象基本特征和原则","slug":"面向对象基本特征和原则","date":"2019-08-21T05:03:56.000Z","updated":"2019-08-21T05:52:20.868Z","comments":true,"path":"2019/08/21/面向对象基本特征和原则/","link":"","permalink":"http://yoursite.com/2019/08/21/面向对象基本特征和原则/","excerpt":"","text":"一、三大基本特征：封装、继承、多态 1、封装 封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体， 也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。 封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。 面相对象的不就是使用程序处理事情时以对象为中心去分析吗，与面向过程不同，面向过程关心处理的逻辑、流程等问题，而不关心事件主体。而面向对象即面向主体， 所以我们在解决问题时应该先进行对象的封装（对象是封装类的实例，比如张三是人，人是一个封装类，张三只是对象中的一个实例、一个对象）。比如我们日常生活中的 小兔子、小绵羊都可以封装为一个类。 比如兔子的属性有两只耳朵、四只腿、一双眼睛、三瓣嘴等；行为（功能）有跑、跳、吃素等。 2、继承 继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类 从父类继承方法，使得子类具有父类相同的行为。类似下面这个图： 我们在上面已经封装了兔子这个类，其他动物也一样可以进行封装。在封装过程中我们发现兔子、绵羊这两个类具有相似的功能或特性如吃草，所以我们可以抽取共有 特征和方法形成高一层的类，如这里的食草动物、食肉动物。继承之间是子父类的关系。继承机制可以很好的描述一个类的生态，也提高了代码复用率，在Java中的Object 类是所有类的超类，常称作上帝类 3、多态 多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享 相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。 多态的优点： 1. 消除类型之间的耦合关系 2. 可替换性 3. 可扩充性 4. 接口性 5. 灵活性 6. 简化性 多态存在的三个必要条件： 继承 重写（子类继承父类后对父类方法进行重新定义） 父类引用指向子类对象 简言之，多态其实是在继承的基础上的。比如说今天我们要去动物园参观动物，那么你说我们去参观兔子、参观绵羊、参观狮子、参观豹子都是对的，但你不能说我们去参观汽车。 在这个例子中，子类具有多态性：除了使用自己的身份，还能充当父类。 二、五大基本原则 1、单一职责原则（SRP） 一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。 比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要if else判断是哪种情况，从类结构上来说将会十分臃肿。 2、开放封闭原则（OCP） 对象或实体应该对扩展开放，对修改封闭。 更改封闭即是在我们对模块进行扩展时，勿需对源有程序代码和DLL进行修改或重新编译文件！这个原则对我们在设计类的时候很有帮助，坚持这个原则就必须尽量考虑接口封装，抽象机制和多态技术！ 3、里氏替换原则（LSP） 在对象 x 为类型 T 时 q(x) 成立，那么当 S 是 T 的子类时，对象 y 为类型 S 时 q(y) 也应成立。（即对父类的调用同样适用于子类） 4、依赖倒置原则（DIP） 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。具体实现应该依赖于抽象，而不是抽象依赖于实现。 可以这样理解，上面我举例子的时候先说了兔子和绵羊，然后才推出食草动物。但如果我们继续认识了牛、马等食草动物，我们会发现我们需要不断调整食草动物的描述，这样程序会变得僵化，所以我们 不应该让子类依赖于实体，不应该让父类模块依赖于子类模块。所以我们需要将食草动物设计为抽象类，即抽象类或接口。这样下层只需要实现相应的细节而不会影响父类。 5、接口隔离原则（ISP） 不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法，使用多个专门的接口比使用单个接口要好的多！ 比如，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后会发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好， 越精练越好，过多的承诺带来的就是你的大量精力和时间去维护！ 这些基本原则需要我们在使用面向对象编程中慢慢领会、总结。","categories":[],"tags":[]},{"title":"Java基础知识总结","slug":"Java基础知识总结","date":"2019-08-21T04:02:29.000Z","updated":"2019-08-22T02:30:38.822Z","comments":true,"path":"2019/08/21/Java基础知识总结/","link":"","permalink":"http://yoursite.com/2019/08/21/Java基础知识总结/","excerpt":"","text":"1.Java的跨平台原理（详情请见https://lzk-super.github.io/2019/08/21/Java%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86/ 由于各操作系统支持的指令集不是完全一致的，就会让我们的程序在不同操作系统上执行不同的代码。Java开发了适用于 不同操作系统及位数的Java虚拟机来屏蔽各个操作系统之间的差异，提供统一的接口，对于我们Java开发者而言，你只需 要在不同的系统上安装对应的Java虚拟机，这时你的Java程序只要遵循Java规范，就可以在所有的操作系统上面运行程序了 2.Java的基本数据类型，各占几个字节以及各自的封装类型都是什么 boolean： 一位（0和1） Boolean byte： 一个字节 Byte short： 两个字节 Short char： 两个字节 Character int： 四个字节 Integer float： 四个字节 Float long： 八个字节 Long double： 八个字节 Double3.已经有基本数据类型了，为什么还要设计数据的封装类型 封装是由Java是面向对象程序设计语言的性质决定的，因为面向对象程序设计语言的三大特性之一就是封装。 至于为什么需要封装，因为面向对象中所有的实体都是以对象为基本单位的，以宏观世界的实体来映射到计算机世界中， 每个对象有它自己的属性和自己的行为，我们用类来将这些属性和行为封装到一起，当它实例化出来一个对象的时候， 我们可以说这个对象具有这些属性和行为。不同类别的对象正是因为这些特性的不同，我们才可以将它们区分开， 而这也正反映了我们现实生活中不同种类个体的不同。 而且在实际应用中，基本数据类型有局限性，比如创建一个用户实体类，字段ID为整形，如果某人ID为空，则int就不好表示， 因为int只有数字，而封装类型为空时可以用null表示，这样判断时只需要判断是否为空即可，而int还要进行是否为零等一系列的判断4.面向对象的三大基本特征和五大基本原则（具体内容见https://lzk-super.github.io/2019/08/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%E5%92%8C%E5%8E%9F%E5%88%99/ 三大基本特征：封装，继承，和多态 五大基本原则：单一职责，开放封闭，里式替换，依赖倒置，接口隔离 5.装箱与拆箱———–见https://lzk-super.github.io/2019/08/21/%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1/ 6.Java中 == 和 equals 的区别 ==比较的是他们在内存中的存放地址 equals是针对开发人员根据功能要求进行重写的方法，如果不重写，和==作用相同7.String,StringBuffer与StringBuilder的区别 一、Java String 类——String字符串常量 字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。 需要注意的是，String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，这样 不仅效率低下，而且大量浪费有限的内存空间。 为了应对经常性的字符串相关的操作，谷歌引入了两个新的类——StringBuffer类和StringBuild类来对此种变化字符串进行处理。 二、Java StringBuffer 和 StringBuilder 类——StringBuffer字符串变量、StringBuilder字符串变量 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 三者的继承结构 {% asset_img 1.png [12] %} 三者的区别： {% asset_img 2.png [12] %} 1）字符修改上的区别（主要，见上面分析） （2）初始化上的区别，String可以空赋值，后者不行，报错 ①String String s = null; String s = “abc”; ②StringBuffer StringBuffer s = null; //结果警告：Null pointer access: The variable result can only be null at this location StringBuffer s = new StringBuffer();//StringBuffer对象是一个空的对象 StringBuffer s = new StringBuffer(“abc”);//创建带有内容的StringBuffer对象,对象的内容就是字符串”小结：（1）如果要操作少量的数据用 String； （2）多线程操作字符串缓冲区下操作大量数据 StringBuffer； （3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。 8.Java中的集合 Java中的集合分为value，key-value（Map）两种 存储value的又分为List和Set List是有序的，可以重复的 List常用的有ArrayList和LinkedList ArrayList底层采用数组，LinkedList底层采用的是链表（数组查询快，链表删除添加快） Set是无序的，不能重复的，存储在Set中必须重写equals和hashCode方法 存储key-value的为Map 9.Map集合 Map集合常用的有HashMap，HashTable和CurrentHashMap HashMap和HashTable的区别 1，HashMap可以把null作为key或value，而HashTable不可以 2，HashMap是线程不安全的，效率高。HashTable是线程安全的，效率较低 如果想线程安全，又想效率高就要用到CurrentHashMap 通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全， 但是效率提升N倍，默认提升16倍10.实现一个拷贝文件的工具类使用字节流还是字符流 传递字符可以用字符流，但是我们拷贝的文件不确定是否只包含字符，所以要用字节流11.设计模式 设计模式就是经过前人无数次的实践总结出来的，设计过程中可以反复使用的，可以解决 特定问题的设计方法 常用的设计模式有 单例模式：构造方法私有化，除了自己类中能创建外其他地方都不能创建 工厂模式：Spring IOC（控制翻转）就是使用了工厂模式，对象交给一个工厂去创建 代理模式：Spring AOP（切面编程）就是使用了动态代理 包装模式12.http get和post请求的区别 get（默认值）是通过URL传递表单值，数据追加在action属性后面。 post传递的表单值是隐藏到http报文体中，url中看不到。 get是通过url传递表单值，post通过url看不到表单域的值； get传递的数据量是有限的，如果要传递大数据量不能用get，比如type=“file”上传文章、 type=“password”传递密码或者&lt;textarea&gt;发表大段文章，post则没有这个限制。 post区别：网址隐藏；只要当前页面请求是POST请求，那么刷新就是重新发出POST，部分浏览器会提示“是否重复提交”。 只要在地址栏中输入一个网址回车访问，那么就是GET。精确到具体网页 数据格式。服务端文件名后跟着“?”，由于客户端可能向服务器端提交多个键值对，键值对之间用“&amp;”进行分割，如果URL中有汉字、 特殊符号等，则需要对URL进行编码。Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. 我们看看GET和POST的区别 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连， 如EditPosts.aspx?name=test1&amp;id=123456.（注意对于用户登录来说，get是不安全的，网页直接显示你的用户名和密码） POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上， 如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.13.Servlet是什么 Servlet（Server Applet），使用Java编写的服务器端程序，而这些Servlet都要实现Servlet这个接口，其主要功能 在于交互式的浏览和修改数据，生成动态web内容，Servlet运行于支持Java的应用服务器中。 HttpServlet重写doGet和doPost方法或者重写service方法完成对get和post请求的响应 生命周期为： 加载Servlet的Class---&gt;实例化Servlet---&gt;调用Servlet的init完成初始化---&gt;响应请求（Service方法）---&gt;Servlet关闭时（destory）14.forword（请求转发）和redirect（重定向）的区别 览器发送http请求----》web服务器接受此请求--》调用内部的一个方法在容器内部完成请求处理和转发动作----》将目标资源发送给客户; 在这 里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。 在客户浏览器路径栏显 示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。 重定向过程：其实是两次request,第一次，客户端request A,服务器响应，并response回来，告诉浏览器，你应该去B。这个时候IE可以看到地址变了， 而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。 在重定向的过程中，传输的信息会被丢失。 以下是区别： 1、从数据共享上 Forword是一个请求的延续，可以共享request的数据 Redirect开启一个新的请求，不可以共享request的数据 2、从地址栏 Forword转发地址栏不发生变化 Redirect转发地址栏发生变化 3. 从运用地方来说 forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等 4. 从效率来说 forward:高. redirect:低.15.JSP和Servlet Jsp和Servlet的相同点： 刚才在上面也提到了，Jsp是在Servlet基础上推出的，即Jsp从本质上来讲是Servlet， 所以Jsp具有Servlet的功能，也就理所当然支持Java语句了。 Jsp和Servlet的不同点： 1、Jsp和Servlet两者创建的方式不一样 2、两者都可以形成Html页面，但是Jsp更直观、方便，因为它可以直接用HTML标签和Javascript； 而Servlet是采用CGI的方式一句一句输出HTML语言标签的，和JSP相比就显得的笨拙了。 ３、现在流行MVC模式，所以都是用Servlet控制业务流程，及Control层，JSP实现View层。16.JSP九大内置对象和四大作用于 jsp是运行在服务端的程序 JSP有九个内置对象（又叫隐含对象），不需要预先声明就可以在脚本代码和表达式中随意使用 JSP九大内置对象分为四类： 输入输出对象：out对象、response对象、request对象 通信控制对象：pageContext对象、session对象、application对象 Servlet对象:page对象、config对象 错误处理对象：exception对象jsp四大作用域： page范围：只在一个页面保留数据（javax.servlet.jsp.PageContext(抽象类)） request范围：只在一个请求中保存数据（javax.servlet.httpServletRequest） Session范围：在一次会话中保存数据，仅供单个用户使用(javax.servlet.http.HttpSession) Application范围：在整个服务器中保存数据，全部用户共享(javax.servlet.ServletContext)九种对象简介： out对象：用于向客户端、浏览器输出数据。 request对象：封装了来自客户端、浏览器的各种信息。 response对象：封装了服务器的响应信息。 exception对象：封装了jsp程序执行过程中发生的异常和错误信息。 config对象：封装了应用程序的配置信息。 page对象：指向了当前jsp程序本身。 session对象：用来保存会话信息。也就是说，可以实现在同一用户的不同请求之间共享数 application对象：代表了当前应用程序的上下文。可以在不同的用户之间共享信息。 pageContext对象：提供了对jsp页面所有对象以及命名空间的访问。17.Session和Cookie的区别 （1）Cookie以文本文件格式存储在浏览器中，而session存储在服务端它存储了限制数据量。它只允许4kb它没有在cookie 中保存多个变量。 （2）cookie的存储限制了数据量，只允许4KB，而session是无限量的 （3）我们可以轻松访问cookie值但是我们无法轻松访问会话值，因此它更安全 （4）设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。 总结：如果我们需要经常登录一个站点时，最好用cookie来保存信息，要不然每次登陆都特别麻烦， 如果对于需要安全性高的站点以及控制数据的能力时需要用会话效果更佳，当然我们也可以结合两者， 使网站按照我们的想法进行运行","categories":[],"tags":[]},{"title":"JDK下载与安装","slug":"JDK下载与安装","date":"2019-08-21T02:32:18.000Z","updated":"2019-08-21T03:42:01.614Z","comments":false,"path":"2019/08/21/JDK下载与安装/","link":"","permalink":"http://yoursite.com/2019/08/21/JDK下载与安装/","excerpt":"","text":"1.JDK下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html 点开链接你应该看到如下图所示的界面： 2点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示： 3.双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：（1）双击进行安装界面如下所示： 4.安装完成后，需要进行环境变量的配置，右键我的电脑—属性—-高级系统设置就会看到下面的界面： 5.点击上图中的环境变量，然后开始环境变量的配置：（1）点击系统变量下面的新建按钮，变量名JAVA_HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。 （2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示： 此处需要注意：最前面有一个英文状态下的小圆点。。。。很多初学者在配置环境变量的时候就会跌倒在这个坑里。（3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码： %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;1此时你应该在你原有的值域后面追加，记得在原有的值域后面记得添加一个英文状态下的分号。最后点击确定，此时JDK的环境变量配置就完成了。 6.测试自己所配置的环境变量是否正确（1）WINDOWS+R键，输入cmd，进入命令行界面，如下所示： （2）输入java -version命令，可以出现如下图的提示，你可以看你安装的JDK版本。 （3）输入javac命令可以出现如下的提示： （4）输入java命令就会出现如下图所示的结果 7.写一段代码可以验证一下（1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava.java，此时需要注意，你的文件名字后缀一定是.java（2）你需要在你的文件里面写下面的代码： 3）继续windows+r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样： 此处一定要注意：必须进入文件所在的目录；其次使用javac命令 文件的名字的后面一定要跟着.java的文件后缀；使用java命令时.java后缀可以不用写。当你执行完javac命令如果没有错误提示，说明通过了编译，就会在你的文件目录下生成一个同名的.class文件。","categories":[],"tags":[]}]